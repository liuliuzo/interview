在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：

blocking IO
A用的是最老式的鱼竿，所以呢，得一直守着，等到鱼上钩了再拉杆；

nonblocking IO
B的鱼竿有个功能，能够显示是否有鱼上钩，所以呢，B就和旁边的MM聊天，隔会再看看有没有鱼上钩，有的话就迅速拉杆；

IO multiplexing
C用的鱼竿和B差不多，但他想了一个好办法，就是同时放好几根鱼竿，然后守在旁边，一旦有显示说鱼上钩了，它就将对应的鱼竿拉起来；

Asynchronous I/O
D是个有钱人，干脆雇了一个人帮他钓鱼，一旦那个人把鱼钓上来了，就给D发个短信。